package tweets;

import java.util.ArrayList;
import java.util.StringTokenizer;

import org.apache.commons.math3.linear.RealMatrix;

import utils.FeatureMatrix;
import utils.Parser;
import libsvm.svm;
import libsvm.svm_model;
import libsvm.svm_node;
import libsvm.svm_parameter;
import libsvm.svm_problem;

/**
 * Design structure from http://stackoverflow.com/questions/10792576/libsvm-java-implementation
 * 
 * @author Ryan Lacey
 *
 */
public class TesterMain {
	
	private static double atof(String s)
	{
		return Double.valueOf(s).doubleValue();
	}
	
	private static int atoi(String s)
	{
		return Integer.parseInt(s);
	}

	void run(String args) {
		svm_parameter param = new svm_parameter();
		
		// default values
		param.svm_type = svm_parameter.C_SVC;
		param.kernel_type = svm_parameter.RBF;
		param.degree = 3;
		param.gamma = 0;
		param.coef0 = 0;
		param.nu = 0.5;
		param.cache_size = 40;
		param.C = 1;
		param.eps = 1e-3;
		param.p = 0.1;
		param.shrinking = 1;
		param.probability = 0;
		param.nr_weight = 0;
		param.weight_label = new int[0];
		param.weight = new double[0];
		
		// parse options
		StringTokenizer st = new StringTokenizer(args);
		String[] argv = new String[st.countTokens()];
		for(int i=0;i<argv.length;i++)
			argv[i] = st.nextToken();

		for(int i=0;i<argv.length;i++)
		{
			if(argv[i].charAt(0) != '-') break;
			if(++i>=argv.length)
			{
				System.err.print("unknown option\n");
				break;
			}
			switch(argv[i-1].charAt(1))
			{
				case 's':
					param.svm_type = atoi(argv[i]);
					break;
				case 't':
					param.kernel_type = atoi(argv[i]);
					break;
				case 'd':
					param.degree = atoi(argv[i]);
					break;
				case 'g':
					param.gamma = atof(argv[i]);
					break;
				case 'r':
					param.coef0 = atof(argv[i]);
					break;
				case 'n':
					param.nu = atof(argv[i]);
					break;
				case 'm':
					param.cache_size = atof(argv[i]);
					break;
				case 'c':
					param.C = atof(argv[i]);
					break;
				case 'e':
					param.eps = atof(argv[i]);
					break;
				case 'p':
					param.p = atof(argv[i]);
					break;
				case 'h':
					param.shrinking = atoi(argv[i]);
					break;
				case 'b':
					param.probability = atoi(argv[i]);
					break;
				case 'w':
					++param.nr_weight;
					{
						int[] old = param.weight_label;
						param.weight_label = new int[param.nr_weight];
						System.arraycopy(old,0,param.weight_label,0,param.nr_weight-1);
					}

					{
						double[] old = param.weight;
						param.weight = new double[param.nr_weight];
						System.arraycopy(old,0,param.weight,0,param.nr_weight-1);
					}

					param.weight_label[param.nr_weight-1] = atoi(argv[i-1].substring(2));
					param.weight[param.nr_weight-1] = atof(argv[i]);
					break;
				default:
					System.err.print("unknown option\n");
			}
		}
		
		// build problem
		svm_problem prob = new svm_problem();
		prob.l = point_list.size();
		prob.y = new double[prob.l];

		if(param.kernel_type == svm_parameter.PRECOMPUTED)
		{
		}
		else if(param.svm_type == svm_parameter.EPSILON_SVR ||
			param.svm_type == svm_parameter.NU_SVR)
		{
			if(param.gamma == 0) param.gamma = 1;
			prob.x = new svm_node[prob.l][1];
			for(int i=0;i<prob.l;i++)
			{
				point p = point_list.elementAt(i);
				prob.x[i][0] = new svm_node();
				prob.x[i][0].index = 1;
				prob.x[i][0].value = p.x;
				prob.y[i] = p.y;
			}

			// build model & classify
			svm_model model = svm.svm_train(prob, param);
			svm_node[] x = new svm_node[1];
			x[0] = new svm_node();
			x[0].index = 1;
			int[] j = new int[XLEN];

			Graphics window_gc = getGraphics();
			for (int i = 0; i < XLEN; i++)
			{
				x[0].value = (double) i / XLEN;
				j[i] = (int)(YLEN*svm.svm_predict(model, x));
			}
			
			buffer_gc.setColor(colors[0]);
			buffer_gc.drawLine(0,0,0,YLEN-1);
			window_gc.setColor(colors[0]);
			window_gc.drawLine(0,0,0,YLEN-1);
			
			int p = (int)(param.p * YLEN);
			for(int i=1;i<XLEN;i++)
			{
				buffer_gc.setColor(colors[0]);
				buffer_gc.drawLine(i,0,i,YLEN-1);
				window_gc.setColor(colors[0]);
				window_gc.drawLine(i,0,i,YLEN-1);

				buffer_gc.setColor(colors[5]);
				window_gc.setColor(colors[5]);
				buffer_gc.drawLine(i-1,j[i-1],i,j[i]);
				window_gc.drawLine(i-1,j[i-1],i,j[i]);

				if(param.svm_type == svm_parameter.EPSILON_SVR)
				{
					buffer_gc.setColor(colors[2]);
					window_gc.setColor(colors[2]);
					buffer_gc.drawLine(i-1,j[i-1]+p,i,j[i]+p);
					window_gc.drawLine(i-1,j[i-1]+p,i,j[i]+p);

					buffer_gc.setColor(colors[2]);
					window_gc.setColor(colors[2]);
					buffer_gc.drawLine(i-1,j[i-1]-p,i,j[i]-p);
					window_gc.drawLine(i-1,j[i-1]-p,i,j[i]-p);
				}
			}
		}
		else
		{
			if(param.gamma == 0) param.gamma = 0.5;
			prob.x = new svm_node [prob.l][2];
			for(int i=0;i<prob.l;i++)
			{
				point p = point_list.elementAt(i);
				prob.x[i][0] = new svm_node();
				prob.x[i][0].index = 1;
				prob.x[i][0].value = p.x;
				prob.x[i][1] = new svm_node();
				prob.x[i][1].index = 2;
				prob.x[i][1].value = p.y;
				prob.y[i] = p.value;
			}

			// build model & classify
			svm_model model = svm.svm_train(prob, param);
			svm_node[] x = new svm_node[2];
			x[0] = new svm_node();
			x[1] = new svm_node();
			x[0].index = 1;
			x[1].index = 2;

			Graphics window_gc = getGraphics();
			for (int i = 0; i < XLEN; i++)
				for (int j = 0; j < YLEN ; j++) {
					x[0].value = (double) i / XLEN;
					x[1].value = (double) j / YLEN;
					double d = svm.svm_predict(model, x);
					if (param.svm_type == svm_parameter.ONE_CLASS && d<0) d=2;
					buffer_gc.setColor(colors[(int)d]);
					window_gc.setColor(colors[(int)d]);
					buffer_gc.drawLine(i,j,i,j);
					window_gc.drawLine(i,j,i,j);
			}
		}
	}
	
	public static void main(String[] argv)
	{
		run(argv);
	}
}
